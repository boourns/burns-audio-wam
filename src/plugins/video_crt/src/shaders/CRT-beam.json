{"shaders":"1","feedback_pass":"0","shader0":"\n// Parameter lines go here:\n#pragma parameter Scanline \"Scanline overall Strength\" 0.5 0.0 2.0 0.05\n#pragma parameter weightr \"Scanline Red Weight\" 0.04 0.0 0.8 0.01\n#pragma parameter weightg \"Scanline Green Weight\" 0.324 0.0 0.8 0.01\n#pragma parameter weightb \"Scanline Blue Weight\" 0.04 0.0 0.8 0.01\n#pragma parameter gap \"Scanline gap Brightness\" 0.06 0.0 1.0 0.01\n#pragma parameter blur \"Blur Horizontal\" 0.70 0.00 1.20 0.10\n#pragma parameter glow \"Glow Strength\" 0.08 0.0 0.3 0.01\n#pragma parameter mask \"Mask -1:Off,0:CGWG,1-2:Lottes,3-4 Gray,5-6:CGWG slot,7 VGA\" 7.0 -1.0 7.0 1.0\n#pragma parameter msk_size \"Mask size\" 1.0 1.0 2.0 1.0\n#pragma parameter scale \"VGA Mask Vertical Scale\" 2.0 2.00 10.00 1.0\n#pragma parameter MaskDark \"Lottes Mask Dark\" 0.50 0.00 2.00 0.10\n#pragma parameter MaskLight \"Lottes Mask Light\" 1.50 0.00 2.00 0.10\n#pragma parameter bright \"Brightness\" 1.06 0.00 2.00 0.02\n#pragma parameter sat \"Saturation, 1.0:Off\" 1.30 0.00 2.00 0.05\n#pragma parameter contrast \"Contrast, 1.0:Off\" 1.1 0.00 2.00 0.05\n#pragma parameter WP \"Color Temperature %, 0.0:Off\" -10.0 -100.0 100.0 5.0 \n#pragma parameter gamma \"Gamma correct, 0.0:Off\" 0.42 0.00 0.60 0.01\n\n#if defined(VERTEX)\n\n#if __VERSION__ >= 130\n#define COMPAT_VARYING out\n#define COMPAT_ATTRIBUTE in\n#define COMPAT_TEXTURE texture\n#else\n#define COMPAT_VARYING varying \n#define COMPAT_ATTRIBUTE attribute \n#define COMPAT_TEXTURE texture2D\n#endif\n\n#ifdef GL_ES\n#define COMPAT_PRECISION mediump\n#else\n#define COMPAT_PRECISION\n#endif\n\nCOMPAT_ATTRIBUTE vec4 VertexCoord;\nCOMPAT_ATTRIBUTE vec4 COLOR;\nCOMPAT_ATTRIBUTE vec4 TexCoord;\nCOMPAT_VARYING vec4 TEX0;\nCOMPAT_VARYING vec2 invDims;\n\n\nvec4 _oPosition1; \nuniform mat4 MVPMatrix;\nuniform COMPAT_PRECISION int FrameDirection;\nuniform COMPAT_PRECISION int FrameCount;\nuniform COMPAT_PRECISION vec2 OutputSize;\nuniform COMPAT_PRECISION vec2 TextureSize;\nuniform COMPAT_PRECISION vec2 InputSize;\n\n// compatibility #defines\n#define vTexCoord TEX0.xy\n#define SourceSize vec4(TextureSize, 1.0 / TextureSize) //either TextureSize or InputSize\n#define OutSize vec4(OutputSize, 1.0 / OutputSize)\n\nvoid main()\n{\n    gl_Position = MVPMatrix * VertexCoord;\n    TEX0.xy = TexCoord.xy * 1.0001;\n    invDims = 1.0/TextureSize.xy;\n\n}\n\n#elif defined(FRAGMENT)\n\n#if __VERSION__ >= 130\n#define COMPAT_VARYING in\n#define COMPAT_TEXTURE texture\nout vec4 FragColor;\n#else\n#define COMPAT_VARYING varying\n#define FragColor gl_FragColor\n#define COMPAT_TEXTURE texture2D\n#endif\n\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#define COMPAT_PRECISION mediump\n#else\n#define COMPAT_PRECISION\n#endif\n\nuniform COMPAT_PRECISION int FrameDirection;\nuniform COMPAT_PRECISION int FrameCount;\nuniform COMPAT_PRECISION vec2 OutputSize;\nuniform COMPAT_PRECISION vec2 TextureSize;\nuniform COMPAT_PRECISION vec2 InputSize;\nuniform sampler2D Texture;\nuniform sampler2D PassPrev2Texture;\nCOMPAT_VARYING vec4 TEX0;\nCOMPAT_VARYING vec2 invDims;\n\n// compatibility #defines\n#define Source Texture\n#define vTexCoord TEX0.xy\n\n\n#ifdef PARAMETER_UNIFORM\n// All parameter floats need to have COMPAT_PRECISION in front of them\nuniform COMPAT_PRECISION float Scanline;\nuniform COMPAT_PRECISION float weightr;\nuniform COMPAT_PRECISION float weightg;\nuniform COMPAT_PRECISION float weightb;\nuniform COMPAT_PRECISION float gap;\nuniform COMPAT_PRECISION float blur;\nuniform COMPAT_PRECISION float glow;\nuniform COMPAT_PRECISION float mask;\nuniform COMPAT_PRECISION float msk_size;\nuniform COMPAT_PRECISION float scale;\nuniform COMPAT_PRECISION float MaskDark;\nuniform COMPAT_PRECISION float MaskLight;\nuniform COMPAT_PRECISION float bright;\nuniform COMPAT_PRECISION float gamma;\nuniform COMPAT_PRECISION float sat;\nuniform COMPAT_PRECISION float contrast;\nuniform COMPAT_PRECISION float WP;\n\n\n#else\n#define Scanline  1.4\n#define weightr  0.33\n#define weightg  0.33\n#define weightb  0.33\n#define gap \t  0.12\n#define mask      0.0\n#define blur      0.5\n#define glow      0.05   \n#define msk_size  1.0\n#define scale   2.0\n#define MaskDark  0.5\n#define MaskLight  1.5\n#define bright    1.06\n#define gamma     0.45\n#define sat       1.1\n#define contrast  1.0\n#define WP  0.0\n\n#endif\n\nvec4 Mask (vec2 p)\n{\t\t\n\t\tp = floor(p/msk_size);\n\t\tfloat mf=fract(p.x*0.5);\n\t\tfloat m=MaskDark;\n\t\tvec3 Mask = vec3 (MaskDark);\n\n// Phosphor.\n\tif (mask==0.0)\n\t{\n\t\tif (mf < 0.5) return vec4 (MaskLight,m,MaskLight,1.0); \n\t\telse return vec4 (m,MaskLight,m,1.0);\n\t}\n\n// Very compressed TV style shadow mask.\n\telse if (mask == 1.0)\n\t{\n\t\tfloat line = MaskLight;\n\t\tfloat odd  = 0.0;\n\n\t\tif (fract(p.x/6.0) < 0.5)\n\t\t\todd = 1.0;\n\t\tif (fract((p.y + odd)/2.0) < 0.5)\n\t\t\tline = MaskDark;\n\n\t\tp.x = fract(p.x/3.0);\n    \n\t\tif      (p.x < 0.333) Mask.r = MaskLight;\n\t\telse if (p.x < 0.666) Mask.g = MaskLight;\n\t\telse                  Mask.b = MaskLight;\n\t\t\n\t\tMask*=line;\n\t\treturn vec4 (Mask.r, Mask.g, Mask.b,1.0);  \n\t} \n\n// Aperture-grille.\n\telse if (mask == 2.0)\n\t{\n\t\tp.x = fract(p.x/3.0);\n\n\t\tif      (p.x < 0.333) Mask.r = MaskLight;\n\t\telse if (p.x < 0.666) Mask.g = MaskLight;\n\t\telse                  Mask.b = MaskLight;\n\t\treturn vec4 (Mask.r, Mask.g, Mask.b,1.0);  \n\n\t} \n// gray\n\telse if (mask==3.0)\n\t{\n\t\t\n\t\tif (mf < 0.5) return vec4 (MaskLight,MaskLight,MaskLight,1.0); \n\t\telse return vec4 (m,m,m,1.0);\n\t}\n//gray 3px\n\telse if (mask==4.0)\n\t{\n\t\tfloat mf=fract(p.x*0.3333);\n\t\tif (mf < 0.6666) return vec4 (MaskLight,MaskLight,MaskLight,1.0); \n\t\telse return vec4 (m,m,m,1.0);\n\t}\n//cgwg slot\n\telse if (mask == 5.0)\n\t{\n\t\tfloat line = MaskLight;\n\t\tfloat odd  = 0.0;\n\n\t\tif (fract(p.x/4.0) < 0.5)\n\t\t\todd = 1.0;\n\t\tif (fract((p.y + odd)/2.0) < 0.5)\n\t\t\tline = MaskDark;\n\n\t\tp.x = fract(p.x/2.0);\n    \n\t\tif  (p.x < 0.5) {Mask.r = MaskLight; Mask.b = MaskLight;}\n\t\telse  Mask.g = MaskLight;\t\n\t\tMask*=line;  \n\t\treturn vec4 (Mask.r, Mask.g, Mask.b,1.0);  \n\n\t} \n\n//cgwg slot 1440p\n\telse if (mask == 6.0)\n\t{\n\t\tfloat line = MaskLight;\n\t\tfloat odd  = 0.0;\n\n\t\tif (fract(p.x/6.0) < 0.5)\n\t\t\todd = 1.0;\n\t\tif (fract((p.y + odd)/3.0) < 0.5)\n\t\t\tline = MaskDark;\n\n\t\tp.x = fract(p.x/2.0);\n    \n\t\tif  (p.x < 0.5) {Mask.r = MaskLight; Mask.b = MaskLight;}\n\t\t\telse  {Mask.g = MaskLight;}\t\n\t\t\n\t\tMask*=line; \n\t\treturn vec4 (Mask.r, Mask.g, Mask.b,1.0);   \n\t} \n\n//PC CRT VGA style mask\n\telse if (mask == 7.0)\n\t{\n\t\tfloat line = 1.0;\n\t\tp.x = fract(p.x/2.0);\n\n\t\tif (fract(p.y/scale) < 0.5)\n\t\t\t{\n\t\t\t\tif  (p.x < 0.5) {Mask.r = MaskLight; Mask.b = MaskLight;}\n\t\t\t\telse  {Mask.g = MaskLight;}\t\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t\tif  (p.x < 0.5) {Mask.g = MaskLight;}\t\n\t\t\t\telse   {Mask.r = MaskLight; Mask.b = MaskLight;}\n\t}\n\t\tMask*=line;\n\t\treturn vec4 (Mask.r, Mask.g, Mask.b,1.0);   \n\n\t} \nelse return vec4(1.0);\n}\n//CRT-Pi scanline code adjusted so that scanline takes in to account the actual emmited pixel light,\n// e.g. blue emits less light on actual CRT.\nfloat CalcScanLine(float dy, vec3 col)\n{\n\n\tfloat lum = (col.r*weightr + col.g*weightg + col.b*weightb);\n\tlum=pow(1.5,lum)-1.0+(lum/2.0);\n\n\tlum=min(lum,0.95);\n\tfloat scan = 1.0;\n\tfloat scanl= dy*dy*20.0*(Scanline-lum); scanl = max(scanl,0.0);\n\tif (dy<=0.50 )\n\t\tscan = max(1.0-scanl, gap);\n\n\treturn scan;\n}\n\nvec4 booster (float pos, vec3 col)\n{\n\n\tfloat lum = (col.r*weightr + col.g*weightg + col.b*weightb);\n\tlum = min (lum,0.9);\n\n\tfloat bo=lum*glow;\n\t\n\tif (fract(pos*0.5)>0.5)\n\t\treturn vec4(bo);\n\telse return vec4(0.0);\t\n\n}\n\n\n// Code from https://www.shadertoy.com/view/XdcXzn\nmat4 saturationMatrix( float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.1520 );\n    \n    float oneMinusSat = 1.0 - saturation;\n    \n    vec3 red = vec3( luminance.x * oneMinusSat ); red+= vec3( saturation, 0, 0 );\n    \n    vec3 green = vec3( luminance.y * oneMinusSat ); green += vec3( 0, saturation, 0 );\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat ); blue += vec3( 0, 0, saturation );\n    \n    return mat4( red,     0,\n                 green,   0,\n                 blue,    0,\n                 0, 0, 0, 1 );\n}\n\nmat4 contrastMatrix( float contrast )\n{\n\tfloat t = ( 1.0 - contrast ) / 2.0;\n    \n    return mat4( contrast, 0, 0, 0,\n                 0, contrast, 0, 0,\n                 0, 0, contrast, 0,\n                 t, t, t, 1 );\n\n}\n\n\n\nconst mat3 D65_to_XYZ = mat3 (\n           0.4306190,  0.2220379,  0.0201853,\n           0.3415419,  0.7066384,  0.1295504,\n           0.1783091,  0.0713236,  0.9390944);\n\nconst mat3 XYZ_to_D65 = mat3 (\n           3.0628971, -0.9692660,  0.0678775,\n          -1.3931791,  1.8760108, -0.2288548,\n          -0.4757517,  0.0415560,  1.0693490);\n\t\t   \nconst mat3 D50_to_XYZ = mat3 (\n           0.4552773,  0.2323025,  0.0145457,\n           0.3675500,  0.7077956,  0.1049154,\n           0.1413926,  0.0599019,  0.7057489);\n\t\t   \nconst mat3 XYZ_to_D50 = mat3 (\n           2.9603944, -0.9787684,  0.0844874,\n          -1.4678519,  1.9161415, -0.2545973,\n          -0.4685105,  0.0334540,  1.4216174);\t\t   \n\n\n\nvoid main()\n{\n//Zfast-CRT filter\n\tvec2 pos = TEX0.xy;\n\tvec2 p = pos * TextureSize; \n\tvec2 i = floor(p)*1.0001 + 0.5;\n\tvec2 f = p - i;\n\tp = (i + 4.0*f*f*f)*invDims;\n\tp.x = mix(p.x, pos.x, blur);\n\n\tvec4 screen = COMPAT_TEXTURE(Source, p);\n//BRIGHTNESS\n\tscreen*=vec4(bright);\n\n\tvec3 mcolor = vec3 (screen.r,screen.g ,screen.b);\n\tfloat scanLineWeight = CalcScanLine(f.y, mcolor);\n\n//COLOR TEMPERATURE FROM GUEST.R-DR.VENOM\nif (WP !=0.0){\n\tvec3 warmer = D50_to_XYZ*mcolor;\n\twarmer = XYZ_to_D65*warmer;\t\n\tvec3 cooler = D65_to_XYZ*mcolor;\n\tcooler = XYZ_to_D50*cooler;\n\tfloat m = abs(WP)/100.0;\n\tvec3 comp = (WP < 0.0) ? cooler : warmer;\t\n\tscreen = vec4(mix(mcolor, comp, m),1.0);\n}\n\n//FAKE GAMMA IN\nif (gamma !=0.0) {screen = screen * screen;}\n\n//APPLY MASK\nif (mask !=-1.0){screen *= Mask(gl_FragCoord.xy*1.0001);}\n\n//GAMMA OUT\nif (gamma !=0.0){screen = pow(screen,vec4(gamma,gamma,gamma,1.0));}\n//BOOST COLORS\t\nif (glow !=0.0)\t{screen+= booster(f.y, mcolor);}\n//APPLY SCANLINES\n\tscreen *= scanLineWeight;\nif (contrast !=1.0) {screen = contrastMatrix(contrast)*screen;}\n    \nif (sat !=1.0) FragColor = saturationMatrix(sat)*screen;\n\t\telse FragColor = screen;\n} \n#endif","filter_linear0":"true","wrap_mode0":"clamp_to_border","mipmap_input0":"false","alias0":"","float_framebuffer0":"false","srgb_framebuffer0":"false"}