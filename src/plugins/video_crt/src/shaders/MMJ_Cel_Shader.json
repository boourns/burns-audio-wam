{"shaders":"1","shader0":"/*\r\nMMJ's Cel Shader - v1.03\r\n----------------------------------------------------------------\r\n-- 180403 --\r\nThis is a port of my old shader from around 2006 for Pete's OGL2 \r\nplugin for ePSXe. It started out as a shader based on the \r\n\"CComic\" shader by Maruke. I liked his concept, but I was \r\nlooking for something a little different in the output. \r\n\r\nSince the last release, I've seen some test screenshots from MAME \r\nusing a port of my original shader and have also seen another \r\nport to get it working with the PCSX2 emulator. Having recently \r\nseen some Kingdom Hearts II and Soul Calibur 3 YouTube videos with \r\nmy ported shader inspired me to revisit it and get it working in \r\nRetroArch.\r\n\r\nAs for this version (1.03), I've made a few small modifications \r\n(such as to remove the OGL2Param references, which were specific \r\nto Pete's plugin) and I added some RetroArch Parameter support, \r\nso some values can now be changed in real time.\r\n\r\nKeep in mind, that this was originally developed for PS1, using\r\nvarious 3D games as a test. In general, it will look better in \r\ngames with less detailed textures, as \"busy\" textures will lead \r\nto more outlining / messy appearance. Increasing \"Outline \r\nBrightness\" can help mitigate this some by lessening the \r\n\"strength\" of the outlines.\r\n\r\nAlso (in regards to PS1 - I haven't really tested other systems \r\ntoo much yet), 1x internal resolution will look terrible. 2x \r\nwill also probably be fairly blurry/messy-looking. For best \r\nresults, you should probably stick to 4x or higher internal \r\nresolution with this shader.\r\n\r\nParameters:\r\n-----------\r\nWhite Level Cutoff = Anything above this luminance value will be \r\n    forced to pure white.\r\n\r\nBlack Level Cutoff = Anything below this luminance value will be \r\n    forced to pure black.\r\n\r\nShading Levels = Determines how many color \"slices\" there should \r\n    be (not counting black/white cutoffs, which are always \r\n    applied).\r\n\r\nSaturation Modifier = Increase or decrease color saturation. \r\n    Default value boosts saturation a little for a more \r\n    cartoonish look. Set to 0.00 for grayscale.\r\n\r\nOutline Brightness = Adjusts darkness of the outlines. At a \r\n    setting of 1, outlines should be disabled.\r\n\r\nShader Strength = Adjusts the weight of the color banding \r\n    portion of the shader from 0% (0.00) to 100% (1.00). At a \r\n    setting of 0.00, you can turn off the color banding effect \r\n    altogether, but still keep outlines enabled.\r\n-----------\r\nMMJuno\r\n*/\r\n\r\n// Parameter lines go here:\r\n#pragma parameter WhtCutoff \"White Level Cutoff\" 0.97 0.50 1.00 0.01\r\n#pragma parameter BlkCutoff \"Black Level Cutoff\" 0.03 0.00 0.50 0.01\r\n#pragma parameter ShdLevels \"Shading Levels\" 9.0 1.0 16.0 1.0\r\n#pragma parameter SatModify \"Saturation Modifier\" 1.15 0.00 2.00 0.01\r\n#pragma parameter OtlModify \"Outline Brightness\" 0.20 0.00 1.00 0.01\r\n#pragma parameter ShdWeight \"Shader Strength\" 0.50 0.00 1.00 0.01\r\n\r\n\r\n#if defined(VERTEX)\r\n\r\n#if __VERSION__ >= 130\r\n#define COMPAT_VARYING out\r\n#define COMPAT_ATTRIBUTE in\r\n#define COMPAT_TEXTURE texture\r\n#else\r\n#define COMPAT_VARYING varying \r\n#define COMPAT_ATTRIBUTE attribute \r\n#define COMPAT_TEXTURE texture2D\r\n#endif\r\n\r\n#ifdef GL_ES\r\n#define COMPAT_PRECISION mediump\r\n#else\r\n#define COMPAT_PRECISION\r\n#endif\r\n\r\nCOMPAT_ATTRIBUTE vec4 VertexCoord;\r\nCOMPAT_ATTRIBUTE vec4 COLOR;\r\nCOMPAT_ATTRIBUTE vec4 TexCoord;\r\nCOMPAT_VARYING vec4 COL0;\r\nCOMPAT_VARYING vec4 TEX0;\r\nCOMPAT_VARYING vec4 TEX1;\r\nCOMPAT_VARYING vec4 TEX2;\r\nCOMPAT_VARYING vec4 TEX3;\r\n\r\nvec4 _oPosition1; \r\nuniform mat4 MVPMatrix;\r\nuniform COMPAT_PRECISION int FrameDirection;\r\nuniform COMPAT_PRECISION int FrameCount;\r\nuniform COMPAT_PRECISION vec2 OutputSize;\r\nuniform COMPAT_PRECISION vec2 TextureSize;\r\nuniform COMPAT_PRECISION vec2 InputSize;\r\n\r\n// compatibility #defines\r\n#define vTexCoord TEX0.xy\r\n#define SourceSize vec4(TextureSize, 1.0 / TextureSize) //either TextureSize or InputSize\r\n#define OutSize vec4(OutputSize, 1.0 / OutputSize)\r\n\r\nvoid main()\r\n{\r\n    vec4 offset;\r\n\r\n    gl_Position = MVPMatrix * VertexCoord;\r\n    \r\n    TEX0 = TexCoord.xyxy;\r\n    \r\n    offset.xy = -(offset.zw = vec2(SourceSize.z, 0.0));\r\n    TEX1 = TEX0 + offset;\r\n    \r\n    offset.xy = -(offset.zw = vec2(0.0, SourceSize.w));\r\n    TEX2 = TEX0 + offset;\r\n    TEX3 = TEX1 + offset;\r\n}\r\n\r\n#elif defined(FRAGMENT)\r\n\r\n#if __VERSION__ >= 130\r\n#define COMPAT_VARYING in\r\n#define COMPAT_TEXTURE texture\r\nout vec4 FragColor;\r\n#else\r\n#define COMPAT_VARYING varying\r\n#define FragColor gl_FragColor\r\n#define COMPAT_TEXTURE texture2D\r\n#endif\r\n\r\n#ifdef GL_ES\r\n#ifdef GL_FRAGMENT_PRECISION_HIGH\r\nprecision highp float;\r\n#else\r\nprecision mediump float;\r\n#endif\r\n#define COMPAT_PRECISION mediump\r\n#else\r\n#define COMPAT_PRECISION\r\n#endif\r\n\r\nuniform COMPAT_PRECISION int FrameDirection;\r\nuniform COMPAT_PRECISION int FrameCount;\r\nuniform COMPAT_PRECISION vec2 OutputSize;\r\nuniform COMPAT_PRECISION vec2 TextureSize;\r\nuniform COMPAT_PRECISION vec2 InputSize;\r\nuniform sampler2D Texture;\r\nCOMPAT_VARYING vec4 TEX0;\r\nCOMPAT_VARYING vec4 TEX1;\r\nCOMPAT_VARYING vec4 TEX2;\r\nCOMPAT_VARYING vec4 TEX3;\r\n\r\n// compatibility #defines\r\n#define Source Texture\r\n#define vTexCoord (TEX0.xy * TextureSize.xy / InputSize.xy)\r\n\r\n#define SourceSize vec4(TextureSize, 1.0 / TextureSize) //either TextureSize or InputSize\r\n#define OutSize vec4(OutputSize, 1.0 / OutputSize)\r\n\r\n#ifdef PARAMETER_UNIFORM\r\nuniform COMPAT_PRECISION float WhtCutoff;\r\nuniform COMPAT_PRECISION float BlkCutoff;\r\nuniform COMPAT_PRECISION float ShdLevels;\r\nuniform COMPAT_PRECISION float SatModify;\r\nuniform COMPAT_PRECISION float OtlModify;\r\nuniform COMPAT_PRECISION float ShdWeight;\r\n#else\r\n#define WhtCutoff 0.97\r\n#define BlkCutoff 0.03\r\n#define ShdLevels 9.0\r\n#define SatModify 1.15\r\n#define OtlModify 0.20\r\n#define ShdWeight 0.50\r\n#endif\r\n\r\nvec3 RGB2HSL(vec3 cRGB) \r\n{\r\n    float cR = cRGB[0], cG = cRGB[1], cB = cRGB[2];\r\n    float vMin = min(min(cR, cG), cB), vMax = max(max(cR, cG), cB);\r\n    float dMax = vMax - vMin, vS = 0.0, vH = 0.0, vL = (vMax + vMin) / 2.0;\r\n\r\n    // gray, no chroma\r\n    if(dMax == 0.0) { \r\n      vH = 0.0; vS = vH; \r\n      \r\n    // chromatic data\r\n    } else {\r\n        if(vL < 0.5) { vS = dMax / (vMax + vMin); }\r\n        else         { vS = dMax / (2.0 - vMax - vMin); }\r\n\r\n        float dR = (((vMax - cR) * 0.1667) + (dMax * 0.5)) / dMax;\r\n        float dG = (((vMax - cG) * 0.1667) + (dMax * 0.5)) / dMax;\r\n        float dB = (((vMax - cB) * 0.1667) + (dMax * 0.5)) / dMax;\r\n\r\n        if     (cR >= vMax) { vH = dB - dG; }\r\n        else if(cG >= vMax) { vH = 0.3333 + dR - dB; }\r\n        else if(cB >= vMax) { vH = 0.6667 + dG - dR; }\r\n\r\n        if     (vH < 0.0) { vH += 1.0; }\r\n        else if(vH > 1.0) { vH -= 1.0; }\r\n    }\r\n    return vec3(vH, vS, vL);\r\n}\r\n\r\nfloat Hue2RGB(float v1, float v2, float vH) \r\n{\r\n    float v3 = 0.0;\r\n\r\n    if     (vH < 0.0) { vH += 1.0; }\r\n    else if(vH > 1.0) { vH -= 1.0; }\r\n\r\n    if     ((6.0 * vH) < 1.0) { v3 = v1 + (v2 - v1) * 6.0 * vH; }\r\n    else if((2.0 * vH) < 1.0) { v3 = v2; }\r\n    else if((3.0 * vH) < 2.0) { v3 = v1 + (v2 - v1) * (0.6667 - vH) * 6.0; }\r\n    else                      { v3 = v1; }\r\n\r\n    return v3;\r\n}\r\n\r\nvec3 HSL2RGB(vec3 vHSL) \r\n{\r\n    float cR = 0.0, cG = cR, cB = cR;\r\n\r\n    if(vHSL[1] == 0.0) {\r\n      cR = vHSL[2], cG = cR, cB = cR;\r\n\r\n    } else {\r\n        float v1 = 0.0, v2 = v1;\r\n\r\n        if(vHSL[2] < 0.5) { v2 = vHSL[2] * (1.0 + vHSL[1] ); }\r\n        else              { v2 = (vHSL[2] + vHSL[1] ) - (vHSL[1] * vHSL[2] ); }\r\n\r\n        v1 = 2.0 * vHSL[2] - v2;\r\n\r\n        cR = Hue2RGB(v1, v2, vHSL[0] + 0.3333);\r\n        cG = Hue2RGB(v1, v2, vHSL[0] );\r\n        cB = Hue2RGB(v1, v2, vHSL[0] - 0.3333);\r\n    }\r\n    return vec3(cR, cG, cB);\r\n}\r\n\r\nvec3 colorAdjust(vec3 cRGB) \r\n{\r\n    vec3 cHSL = RGB2HSL(cRGB);\r\n\r\n    float cr = 1.0 / ShdLevels;\r\n\r\n    // brightness modifier\r\n    float BrtModify = mod(cHSL[2], cr); \r\n\r\n    if     (cHSL[2] > WhtCutoff) { cHSL[1]  = 1.0; cHSL[2] = 1.0; }\r\n    else if(cHSL[2] > BlkCutoff) { cHSL[1] *= SatModify; cHSL[2] += (cHSL[2] * cr - BrtModify); }\r\n    else                         { cHSL[1]  = 0.0; cHSL[2] = 0.0; }\r\n    cRGB = 1.2 * HSL2RGB(cHSL);\r\n\r\n    return cRGB;\r\n}\r\n\r\n\r\nvoid main()\r\n{\r\n    vec3 c0 = COMPAT_TEXTURE(Source, TEX3.xy).rgb;\r\n    vec3 c1 = COMPAT_TEXTURE(Source, TEX2.xy).rgb;\r\n    vec3 c2 = COMPAT_TEXTURE(Source, TEX3.zy).rgb;\r\n    vec3 c3 = COMPAT_TEXTURE(Source, TEX1.xy).rgb;\r\n    vec3 c4 = COMPAT_TEXTURE(Source, TEX0.xy).rgb;\r\n    vec3 c5 = COMPAT_TEXTURE(Source, TEX1.zw).rgb;\r\n    vec3 c6 = COMPAT_TEXTURE(Source, TEX3.xw).rgb;\r\n    vec3 c7 = COMPAT_TEXTURE(Source, TEX2.zw).rgb;\r\n    vec3 c8 = COMPAT_TEXTURE(Source, TEX3.zw).rgb;\r\n\r\n    vec3 c9 = ((c0 + c2 + c6 + c8) * 0.15 + (c1 + c3 + c5 + c7) * 0.25 + c4) / 2.6;\r\n\r\n    vec3 o = vec3(1.0); vec3 h = vec3(0.05); vec3 hz = h; float k = 0.005; \r\n    float kz = 0.007; float i = 0.0;\r\n\r\n    vec3 cz = (c9 + h) / (dot(o, c9) + k);\r\n\r\n    hz = (cz - ((c0 + h) / (dot(o, c0) + k))); i  = kz / (dot(hz, hz) + kz);\r\n    hz = (cz - ((c1 + h) / (dot(o, c1) + k))); i += kz / (dot(hz, hz) + kz);\r\n    hz = (cz - ((c2 + h) / (dot(o, c2) + k))); i += kz / (dot(hz, hz) + kz);\r\n    hz = (cz - ((c3 + h) / (dot(o, c3) + k))); i += kz / (dot(hz, hz) + kz);\r\n    hz = (cz - ((c5 + h) / (dot(o, c5) + k))); i += kz / (dot(hz, hz) + kz);\r\n    hz = (cz - ((c6 + h) / (dot(o, c6) + k))); i += kz / (dot(hz, hz) + kz);\r\n    hz = (cz - ((c7 + h) / (dot(o, c7) + k))); i += kz / (dot(hz, hz) + kz);\r\n    hz = (cz - ((c8 + h) / (dot(o, c8) + k))); i += kz / (dot(hz, hz) + kz);\r\n\r\n    i /= 8.0; i = pow(i, 0.75);\r\n\r\n    if(i < OtlModify) { i = OtlModify; }\r\n    c9 = min(o, min(c9, c9 + dot(o, c9)));\r\n    FragColor.rgb = mix(c4 * i, colorAdjust(c9 * i), ShdWeight);\r\n} \r\n#endif","srgb_framebuffer0":"true"}